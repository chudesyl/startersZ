import { supabase } from '@/integrations/supabase/client';
import { PaymentValidator } from './payment-validators';

export interface PaystackConfig {
  public_key: string;
  secret_key?: string;
  webhook_secret?: string;
  test_mode: boolean;
}

export interface PaystackTransaction {
  email: string;
  amount: number;
  currency?: string;
  reference?: string;
  callback_url?: string;
  metadata?: Record<string, any>;
  channels?: string[];
}

export interface PaystackVerification {
  status: string;
  reference: string;
  amount: number;
  currency: string;
  paid_at: string;
  channel: string;
  gateway_response: string;
  fees: number;
  authorization?: {
    authorization_code: string;
    card_type: string;
    last4: string;
    exp_month: string;
    exp_year: string;
    bank: string;
    account_name: string;
  };
}

/**
 * Validates that a payment reference follows the server-generated format
 * All valid payment references must start with 'txn_' (generated by server)
 */
export function assertServerReference(reference: string): void {
  if (!reference || typeof reference !== 'string') {
    console.error('Payment reference is required and must be a string');
    return;
  }
  
  if (!reference.startsWith('txn_')) {
    console.warn(`Invalid payment reference format: ${reference}. Expected server-generated reference starting with 'txn_'`);
    // Do not throw; allow caller to decide on fallback behavior
  }
}

/**
 * Helper to validate and warn about non-server references during verification
 */
export function validateReferenceForVerification(reference: string): boolean {
  if (!reference || typeof reference !== 'string') {
    console.error('Verification attempted with invalid reference:', reference);
    return false;
  }
  
  if (!reference.startsWith('txn_')) {
    console.warn(`Verification attempted with non-server reference: ${reference}. This may indicate a legacy or test reference.`);
    // Allow verification to proceed but log the warning
    return true;
  }
  
  return true;
}

class PaystackService {
  private baseURL = 'https://api.paystack.co';

  async getConfig(): Promise<PaystackConfig | null> {
    try {
      // Use the environment-aware configuration function
      const { data, error } = await (supabase.rpc as any)('get_public_paystack_config');

      if (error || !data) {
        console.error('Failed to get Paystack config:', error);
        return null;
      }

      // RPC returns a single row, not an array
      const configData = Array.isArray(data) ? data[0] : data;

      return {
        public_key: configData.public_key,
        test_mode: configData.test_mode,
      };
    } catch (error) {
      console.error('Error getting Paystack config:', error);
      return null;
    }
  }

  async initializeTransaction(transactionData: PaystackTransaction) {
    try {
      console.log('üîê Initializing payment via secure backend');
      
      // Enhanced payload with proper structure
      const requestPayload = {
        action: 'initialize',
        email: transactionData.email,
        amount: transactionData.amount,
        callback_url: transactionData.callback_url,
        metadata: transactionData.metadata,
        order_id: transactionData.metadata?.order_id || transactionData.metadata?.orderId
      };

      console.log('üìû Calling paystack-secure with payload:', {
        email: requestPayload.email,
        amount: requestPayload.amount,
        hasCallback: !!requestPayload.callback_url,
        hasMetadata: !!requestPayload.metadata,
        order_id: requestPayload.order_id
      });

      const response = await supabase.functions.invoke('paystack-secure', {
        body: requestPayload,
      });

      console.log('üì¶ Backend response received:', { 
        hasData: !!response.data,
        hasError: !!response.error,
        status: response.data?.status
      });

      if (response.error) {
        console.error('‚ùå Backend initialization failed:', response.error);
        throw new Error(response.error.message || 'Payment initialization failed');
      }

      if (!response.data?.status || !response.data?.data) {
        console.error('‚ùå Invalid backend response:', response.data);
        throw new Error(response.data?.error || response.data?.message || 'Invalid response from payment service');
      }

      const paymentData = response.data.data;
      console.log('‚úÖ Payment initialized successfully:', {
        reference: paymentData.reference,
        hasUrl: !!paymentData.authorization_url
      });

      // Validate server-generated reference
      if (paymentData.reference) {
        assertServerReference(paymentData.reference);
      }

      return paymentData;
    } catch (error) {
      console.error('‚ùå Payment initialization error:', error);
      throw error;
    }
  }

  async verifyTransaction(reference: string) {
    try {
      // Validate reference format before verification
      if (!validateReferenceForVerification(reference)) {
        throw new Error('Invalid reference format for verification');
      }

      // Use the new secure endpoint
      const response = await supabase.functions.invoke('paystack-secure', {
        body: {
          action: 'verify',
          reference,
        },
      });

      // üîç DEBUG: Log verification response
      try {
        console.log('Verification result (paystack-secure):', JSON.stringify(response.data, null, 2));
      } catch {
        console.log('Verification result (raw):', response.data);
      }

      if (response.error) {
        throw new Error(response.error.message);
      }

      if (!response.data?.status) {
        throw new Error(response.data?.error || 'Failed to verify payment');
      }

      return response.data.data;
    } catch (error) {
      console.error('Failed to verify Paystack transaction:', error);
      throw error;
    }
  }

  async chargeAuthorization(chargeData: {
    authorization_code: string;
    email: string;
    amount: number;
    reference?: string;
    metadata?: Record<string, any>;
  }) {
    try {
      // Use the new secure endpoint
      const response = await supabase.functions.invoke('paystack-secure', {
        body: {
          action: 'charge',
          ...chargeData
        },
      });

      if (response.error) {
        throw new Error(response.error.message);
      }

      if (!response.data?.status) {
        throw new Error(response.data?.error || 'Failed to charge payment');
      }

      return response.data.data;
    } catch (error) {
      console.error('Failed to charge authorization:', error);
      throw error;
    }
  }

  async getBanks() {
    try {
      const response = await supabase.functions.invoke('paystack-banks');

      if (response.error) {
        throw new Error(response.error.message);
      }

      if (!response.data?.status) {
        throw new Error(response.data?.error || 'Failed to fetch banks');
      }

      return response.data.data;
    } catch (error) {
      console.error('Failed to fetch banks:', error);
      throw error;
    }
  }

  /**
   * @deprecated This method has been removed for security reasons.
   * All payment references must be generated server-side via the paystack-secure endpoint.
   * Use initializeTransaction() to get a proper server-generated reference.
   */
  generateReference(): never {
    throw new Error(
      'Client-side reference generation is deprecated and disabled for security. ' +
      'Use initializeTransaction() to get a server-generated reference starting with "txn_".'
    );
  }

  formatAmount(amount: number): number {
    // Use secure amount validation and conversion
    const validation = PaymentValidator.validateAmount(amount, 'NGN');
    if (!validation.isValid) {
      throw new Error(`Invalid amount: ${validation.errors.join(', ')}`);
    }
    return validation.subunitAmount;
  }

  formatCurrency(amount: number, currency = 'NGN'): string {
    return new Intl.NumberFormat('en-NG', {
      style: 'currency',
      currency,
    }).format(amount);
  }

  /**
   * Helper method to reinitialize payment if reference validation fails
   */
  async reinitializeIfNeeded(
    originalReference: string,
    transactionData: PaystackTransaction
  ): Promise<string> {
    try {
      assertServerReference(originalReference);
      return originalReference;
    } catch (error) {
      console.warn('Invalid reference detected, reinitializing payment:', originalReference);
      
      // Reinitialize to get a proper server reference
      const response = await this.initializeTransaction(transactionData);
      
      if (!response.reference) {
        throw new Error('Failed to get valid reference during reinitialization');
      }
      
      return response.reference;
    }
  }
}

export const paystackService = new PaystackService();