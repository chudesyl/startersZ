import { supabase } from '@/integrations/supabase/client';
import { PaymentValidator } from './payment-validators';
import { 
  PaymentError, 
  NetworkError, 
  ApplicationError, 
  ErrorSeverity, 
  ErrorCategory,
  errorLogger,
  withRetry,
  apiCall 
} from './error-handling';
import type { PaymentRequest, PaymentResponse } from '@/types';

export interface PaystackConfig {
  public_key: string;
  secret_key?: string;
  webhook_secret?: string;
  test_mode: boolean;
}

export interface PaystackTransaction {
  email: string;
  amount: number;
  currency?: string;
  reference?: string;
  callback_url?: string;
  metadata?: Record<string, any>;
  channels?: string[];
}

export interface PaystackVerification {
  status: string;
  reference: string;
  amount: number;
  currency: string;
  paid_at: string;
  channel: string;
  gateway_response: string;
  fees: number;
  authorization?: {
    authorization_code: string;
    card_type: string;
    last4: string;
    exp_month: string;
    exp_year: string;
    bank: string;
    account_name: string;
  };
}

/**
 * Validates that a payment reference follows the server-generated format
 * All valid payment references must start with 'txn_' (generated by server)
 */
export function assertServerReference(reference: string): void {
  if (!reference || typeof reference !== 'string') {
    const error = new PaymentError('Payment reference is required and must be a string', {
      reference,
      type: 'invalid_reference_type'
    });
    errorLogger.log(error);
    throw error;
  }
  
  if (!reference.startsWith('txn_')) {
    const error = new PaymentError(
      `Invalid payment reference format: ${reference}. Expected server-generated reference starting with 'txn_'`,
      { reference, type: 'invalid_reference_format' }
    );
    errorLogger.log(error);
    throw error;
  }
}

/**
 * Helper to validate and warn about non-server references during verification
 */
export function validateReferenceForVerification(reference: string): boolean {
  if (!reference || typeof reference !== 'string') {
    errorLogger.log(new PaymentError('Verification attempted with invalid reference', {
      reference,
      type: 'verification_invalid_reference'
    }));
    return false;
  }
  
  if (!reference.startsWith('txn_')) {
    errorLogger.log(new PaymentError(
      `Verification attempted with non-server reference: ${reference}. This may indicate a legacy or test reference.`,
      { reference, type: 'verification_non_server_reference' }
    ));
    // Allow verification to proceed but log the warning
    return true;
  }
  
  return true;
}

class PaystackService {
  private baseURL = 'https://api.paystack.co';

  async getConfig(): Promise<PaystackConfig | null> {
    const result = await apiCall(async () => {
      const { data, error } = await (supabase.rpc as any)('get_public_paystack_config');

      if (error || !data) {
        throw new PaymentError('Failed to get Paystack config', { error });
      }

      // RPC returns a single row, not an array
      const configData = Array.isArray(data) ? data[0] : data;

      // Validate config data
      if (!configData?.public_key) {
        throw new PaymentError('Invalid Paystack configuration: missing public key');
      }

      return {
        public_key: configData.public_key,
        test_mode: configData.test_mode,
      };
    }, 'PaystackService.getConfig');

    if (!result.success) {
      return null;
    }

    return result.data || null;
  }

  async initializeTransaction(transactionData: PaystackTransaction): Promise<any> {
    // Validate transaction data
    try {
      const validation = PaymentValidator.validateAmount(transactionData.amount, 'NGN');
      if (!validation.isValid) {
        throw new PaymentError(`Invalid amount: ${validation.errors.join(', ')}`, {
          amount: transactionData.amount,
          errors: validation.errors
        });
      }

      if (!transactionData.email || !/\S+@\S+\.\S+/.test(transactionData.email)) {
        throw new PaymentError('Invalid email address', { email: transactionData.email });
      }
    } catch (error) {
      errorLogger.log(error instanceof PaymentError ? error : new PaymentError('Validation failed', { error }));
      throw error;
    }

    // Use retry mechanism for payment initialization
    return await withRetry(async () => {
      console.log('üîê Initializing payment via secure backend');
      
      // Enhanced payload with proper structure
      const requestPayload = {
        action: 'initialize',
        email: transactionData.email,
        amount: transactionData.amount,
        callback_url: transactionData.callback_url,
        metadata: transactionData.metadata,
        order_id: transactionData.metadata?.order_id || transactionData.metadata?.orderId
      };

      console.log('üìû Calling paystack-secure with payload:', {
        email: requestPayload.email,
        amount: requestPayload.amount,
        hasCallback: !!requestPayload.callback_url,
        hasMetadata: !!requestPayload.metadata,
        order_id: requestPayload.order_id
      });

      const response = await supabase.functions.invoke('paystack-secure', {
        body: requestPayload,
      });

      console.log('üì¶ Backend response received:', { 
        hasData: !!response.data,
        hasError: !!response.error,
        status: response.data?.status
      });

      if (response.error) {
        throw new NetworkError(`Backend initialization failed: ${response.error.message || 'Unknown error'}`, {
          endpoint: 'paystack-secure',
          action: 'initialize',
          originalError: response.error
        });
      }

      if (!response.data?.status || !response.data?.data) {
        throw new PaymentError('Invalid response from payment service', {
          response: response.data,
          expectedStatus: true,
          expectedData: true
        });
      }

      const paymentData = response.data.data;
      console.log('‚úÖ Payment initialized successfully:', {
        reference: paymentData.reference,
        hasUrl: !!paymentData.authorization_url
      });

      // Validate server-generated reference
      if (paymentData.reference) {
        assertServerReference(paymentData.reference);
      }

      return paymentData;
    }, 3, 2000);
  }

  async verifyTransaction(reference: string): Promise<PaystackVerification> {
    // Validate reference format before verification
    if (!validateReferenceForVerification(reference)) {
      throw new PaymentError('Invalid reference format for verification', { reference });
    }

    return await withRetry(async () => {
      // Use the new secure endpoint
      const response = await supabase.functions.invoke('paystack-secure', {
        body: {
          action: 'verify',
          reference,
        },
      });

      // üîç DEBUG: Log verification response
      try {
        console.log('Verification result (paystack-secure):', JSON.stringify(response.data, null, 2));
      } catch {
        console.log('Verification result (raw):', response.data);
      }

      if (response.error) {
        throw new NetworkError(`Verification failed: ${response.error.message}`, {
          endpoint: 'paystack-secure',
          action: 'verify',
          reference,
          originalError: response.error
        });
      }

      if (!response.data?.status) {
        throw new PaymentError('Payment verification failed', {
          response: response.data,
          reference
        });
      }

      return response.data.data;
    }, 2, 1500);
  }

  async chargeAuthorization(chargeData: {
    authorization_code: string;
    email: string;
    amount: number;
    reference?: string;
    metadata?: Record<string, any>;
  }): Promise<any> {
    // Validate charge data
    if (!chargeData.authorization_code) {
      throw new PaymentError('Authorization code is required', { chargeData });
    }

    if (!chargeData.email || !/\S+@\S+\.\S+/.test(chargeData.email)) {
      throw new PaymentError('Valid email address is required', { email: chargeData.email });
    }

    const validation = PaymentValidator.validateAmount(chargeData.amount, 'NGN');
    if (!validation.isValid) {
      throw new PaymentError(`Invalid charge amount: ${validation.errors.join(', ')}`, {
        amount: chargeData.amount,
        errors: validation.errors
      });
    }

    return await withRetry(async () => {
      // Use the new secure endpoint
      const response = await supabase.functions.invoke('paystack-secure', {
        body: {
          action: 'charge',
          ...chargeData
        },
      });

      if (response.error) {
        throw new NetworkError(`Charge authorization failed: ${response.error.message}`, {
          endpoint: 'paystack-secure',
          action: 'charge',
          chargeData,
          originalError: response.error
        });
      }

      if (!response.data?.status) {
        throw new PaymentError('Failed to charge authorization', {
          response: response.data,
          chargeData
        });
      }

      return response.data.data;
    }, 2, 1500);
  }

  async getBanks(): Promise<any[]> {
    return await withRetry(async () => {
      const response = await supabase.functions.invoke('paystack-banks');

      if (response.error) {
        throw new NetworkError(`Failed to fetch banks: ${response.error.message}`, {
          endpoint: 'paystack-banks',
          originalError: response.error
        });
      }

      if (!response.data?.status) {
        throw new PaymentError('Failed to fetch banks list', {
          response: response.data
        });
      }

      return response.data.data || [];
    }, 2, 1000);
  }

  /**
   * @deprecated This method has been removed for security reasons.
   * All payment references must be generated server-side via the paystack-secure endpoint.
   * Use initializeTransaction() to get a proper server-generated reference.
   */
  generateReference(): never {
    const error = new PaymentError(
      'Client-side reference generation is deprecated and disabled for security. ' +
      'Use initializeTransaction() to get a server-generated reference starting with "txn_".',
      { type: 'deprecated_method' }
    );
    errorLogger.log(error);
    throw error;
  }

  formatAmount(amount: number): number {
    // Use secure amount validation and conversion
    const validation = PaymentValidator.validateAmount(amount, 'NGN');
    if (!validation.isValid) {
      throw new PaymentError(`Invalid amount: ${validation.errors.join(', ')}`, {
        amount,
        errors: validation.errors
      });
    }
    return validation.subunitAmount;
  }

  formatCurrency(amount: number, currency = 'NGN'): string {
    try {
      return new Intl.NumberFormat('en-NG', {
        style: 'currency',
        currency,
      }).format(amount);
    } catch (error) {
      errorLogger.log(new PaymentError('Currency formatting failed', {
        amount,
        currency,
        originalError: error
      }));
      return `${currency} ${amount.toFixed(2)}`;
    }
  }

  /**
   * Helper method to reinitialize payment if reference validation fails
   */
  async reinitializeIfNeeded(
    originalReference: string,
    transactionData: PaystackTransaction
  ): Promise<string> {
    try {
      assertServerReference(originalReference);
      return originalReference;
    } catch (error) {
      errorLogger.log(new PaymentError('Invalid reference detected, reinitializing payment', {
        originalReference,
        originalError: error
      }));
      
      // Reinitialize to get a proper server reference
      const response = await this.initializeTransaction(transactionData);
      
      if (!response.reference) {
        throw new PaymentError('Failed to get valid reference during reinitialization', {
          originalReference,
          response
        });
      }
      
      return response.reference;
    }
  }
}

export const paystackService = new PaystackService();

export interface PaystackConfig {
  public_key: string;
  secret_key?: string;
  webhook_secret?: string;
  test_mode: boolean;
}

export interface PaystackTransaction {
  email: string;
  amount: number;
  currency?: string;
  reference?: string;
  callback_url?: string;
  metadata?: Record<string, any>;
  channels?: string[];
}

export interface PaystackVerification {
  status: string;
  reference: string;
  amount: number;
  currency: string;
  paid_at: string;
  channel: string;
  gateway_response: string;
  fees: number;
  authorization?: {
    authorization_code: string;
    card_type: string;
    last4: string;
    exp_month: string;
    exp_year: string;
    bank: string;
    account_name: string;
  };
}

/**
 * Validates that a payment reference follows the server-generated format
 * All valid payment references must start with 'txn_' (generated by server)
 */
export function assertServerReference(reference: string): void {
  if (!reference || typeof reference !== 'string') {
    console.error('Payment reference is required and must be a string');
    return;
  }
  
  if (!reference.startsWith('txn_')) {
    console.warn(`Invalid payment reference format: ${reference}. Expected server-generated reference starting with 'txn_'`);
    // Do not throw; allow caller to decide on fallback behavior
  }
}

/**
 * Helper to validate and warn about non-server references during verification
 */
export function validateReferenceForVerification(reference: string): boolean {
  if (!reference || typeof reference !== 'string') {
    console.error('Verification attempted with invalid reference:', reference);
    return false;
  }
  
  if (!reference.startsWith('txn_')) {
    console.warn(`Verification attempted with non-server reference: ${reference}. This may indicate a legacy or test reference.`);
    // Allow verification to proceed but log the warning
    return true;
  }
  
  return true;
}

class PaystackService {
  private baseURL = 'https://api.paystack.co';

  async getConfig(): Promise<PaystackConfig | null> {
    try {
      // Use the environment-aware configuration function
      const { data, error } = await (supabase.rpc as any)('get_public_paystack_config');

      if (error || !data) {
        console.error('Failed to get Paystack config:', error);
        return null;
      }

      // RPC returns a single row, not an array
      const configData = Array.isArray(data) ? data[0] : data;

      return {
        public_key: configData.public_key,
        test_mode: configData.test_mode,
      };
    } catch (error) {
      console.error('Error getting Paystack config:', error);
      return null;
    }
  }

  async initializeTransaction(transactionData: PaystackTransaction) {
    try {
      console.log('üîê Initializing payment via secure backend');
      
      // Enhanced payload with proper structure
      const requestPayload = {
        action: 'initialize',
        email: transactionData.email,
        amount: transactionData.amount,
        callback_url: transactionData.callback_url,
        metadata: transactionData.metadata,
        order_id: transactionData.metadata?.order_id || transactionData.metadata?.orderId
      };

      console.log('üìû Calling paystack-secure with payload:', {
        email: requestPayload.email,
        amount: requestPayload.amount,
        hasCallback: !!requestPayload.callback_url,
        hasMetadata: !!requestPayload.metadata,
        order_id: requestPayload.order_id
      });

      const response = await supabase.functions.invoke('paystack-secure', {
        body: requestPayload,
      });

      console.log('üì¶ Backend response received:', { 
        hasData: !!response.data,
        hasError: !!response.error,
        status: response.data?.status
      });

      if (response.error) {
        console.error('‚ùå Backend initialization failed:', response.error);
        throw new Error(response.error.message || 'Payment initialization failed');
      }

      if (!response.data?.status || !response.data?.data) {
        console.error('‚ùå Invalid backend response:', response.data);
        throw new Error(response.data?.error || response.data?.message || 'Invalid response from payment service');
      }

      const paymentData = response.data.data;
      console.log('‚úÖ Payment initialized successfully:', {
        reference: paymentData.reference,
        hasUrl: !!paymentData.authorization_url
      });

      // Validate server-generated reference
      if (paymentData.reference) {
        assertServerReference(paymentData.reference);
      }

      return paymentData;
    } catch (error) {
      console.error('‚ùå Payment initialization error:', error);
      throw error;
    }
  }

  async verifyTransaction(reference: string) {
    try {
      // Validate reference format before verification
      if (!validateReferenceForVerification(reference)) {
        throw new Error('Invalid reference format for verification');
      }

      // Use the new secure endpoint
      const response = await supabase.functions.invoke('paystack-secure', {
        body: {
          action: 'verify',
          reference,
        },
      });

      // üîç DEBUG: Log verification response
      try {
        console.log('Verification result (paystack-secure):', JSON.stringify(response.data, null, 2));
      } catch {
        console.log('Verification result (raw):', response.data);
      }

      if (response.error) {
        throw new Error(response.error.message);
      }

      if (!response.data?.status) {
        throw new Error(response.data?.error || 'Failed to verify payment');
      }

      return response.data.data;
    } catch (error) {
      console.error('Failed to verify Paystack transaction:', error);
      throw error;
    }
  }

  async chargeAuthorization(chargeData: {
    authorization_code: string;
    email: string;
    amount: number;
    reference?: string;
    metadata?: Record<string, any>;
  }) {
    try {
      // Use the new secure endpoint
      const response = await supabase.functions.invoke('paystack-secure', {
        body: {
          action: 'charge',
          ...chargeData
        },
      });

      if (response.error) {
        throw new Error(response.error.message);
      }

      if (!response.data?.status) {
        throw new Error(response.data?.error || 'Failed to charge payment');
      }

      return response.data.data;
    } catch (error) {
      console.error('Failed to charge authorization:', error);
      throw error;
    }
  }

  async getBanks() {
    try {
      const response = await supabase.functions.invoke('paystack-banks');

      if (response.error) {
        throw new Error(response.error.message);
      }

      if (!response.data?.status) {
        throw new Error(response.data?.error || 'Failed to fetch banks');
      }

      return response.data.data;
    } catch (error) {
      console.error('Failed to fetch banks:', error);
      throw error;
    }
  }

  /**
   * @deprecated This method has been removed for security reasons.
   * All payment references must be generated server-side via the paystack-secure endpoint.
   * Use initializeTransaction() to get a proper server-generated reference.
   */
  generateReference(): never {
    throw new Error(
      'Client-side reference generation is deprecated and disabled for security. ' +
      'Use initializeTransaction() to get a server-generated reference starting with "txn_".'
    );
  }

  formatAmount(amount: number): number {
    // Use secure amount validation and conversion
    const validation = PaymentValidator.validateAmount(amount, 'NGN');
    if (!validation.isValid) {
      throw new Error(`Invalid amount: ${validation.errors.join(', ')}`);
    }
    return validation.subunitAmount;
  }

  formatCurrency(amount: number, currency = 'NGN'): string {
    return new Intl.NumberFormat('en-NG', {
      style: 'currency',
      currency,
    }).format(amount);
  }

  /**
   * Helper method to reinitialize payment if reference validation fails
   */
  async reinitializeIfNeeded(
    originalReference: string,
    transactionData: PaystackTransaction
  ): Promise<string> {
    try {
      assertServerReference(originalReference);
      return originalReference;
    } catch (error) {
      console.warn('Invalid reference detected, reinitializing payment:', originalReference);
      
      // Reinitialize to get a proper server reference
      const response = await this.initializeTransaction(transactionData);
      
      if (!response.reference) {
        throw new Error('Failed to get valid reference during reinitialization');
      }
      
      return response.reference;
    }
  }
}

export const paystackService = new PaystackService();