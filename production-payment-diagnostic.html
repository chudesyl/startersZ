<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üö® Production Payment Diagnostic</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px; 
            background: #f8f9fa;
        }
        .diagnostic-result { padding: 15px; margin: 15px 0; border-radius: 8px; border-left: 4px solid; }
        .critical { background: #fff5f5; color: #c53030; border-left-color: #e53e3e; }
        .warning { background: #fffbeb; color: #d69e2e; border-left-color: #f6ad55; }
        .success { background: #f0fff4; color: #38a169; border-left-color: #68d391; }
        .info { background: #ebf8ff; color: #2b6cb0; border-left-color: #4299e1; }
        
        .card { 
            background: white; 
            border-radius: 12px; 
            padding: 20px; 
            margin: 20px 0; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .grid { display: grid; gap: 20px; margin: 20px 0; }
        .grid-2 { grid-template-columns: 1fr 1fr; }
        .grid-4 { grid-template-columns: repeat(4, 1fr); }
        
        .stat-card { 
            text-align: center; 
            padding: 20px; 
            border-radius: 8px; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .stat-number { font-size: 2.5rem; font-weight: bold; margin: 10px 0; }
        .stat-label { font-size: 0.9rem; opacity: 0.9; }
        
        button { 
            padding: 12px 24px; 
            margin: 8px; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-primary { background: #4299e1; color: white; }
        .btn-primary:hover { background: #3182ce; }
        .btn-danger { background: #e53e3e; color: white; }
        .btn-danger:hover { background: #c53030; }
        .btn-success { background: #38a169; color: white; }
        .btn-success:hover { background: #2f855a; }
        .btn-secondary { background: #718096; color: white; }
        .btn-secondary:hover { background: #4a5568; }
        
        table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0; }
        th { background: #f7fafc; font-weight: 600; }
        
        .status-badge { 
            padding: 4px 12px; 
            border-radius: 20px; 
            font-size: 12px; 
            font-weight: bold; 
            text-transform: uppercase;
        }
        .badge-success { background: #c6f6d5; color: #22543d; }
        .badge-warning { background: #faf089; color: #744210; }
        .badge-danger { background: #fed7d7; color: #742a2a; }
        
        .loading { display: inline-block; width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .progress-bar { 
            width: 100%; 
            height: 8px; 
            background: #e2e8f0; 
            border-radius: 4px; 
            overflow: hidden; 
            margin: 8px 0;
        }
        .progress-fill { height: 100%; background: #4299e1; transition: width 0.3s ease; }
        
        .environment-badge {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 12px;
            z-index: 1000;
        }
        .env-production { background: #fed7d7; color: #742a2a; }
        .env-development { background: #c6f6d5; color: #22543d; }
        
        pre { 
            background: #1a202c; 
            color: #e2e8f0; 
            padding: 16px; 
            border-radius: 8px; 
            overflow-x: auto; 
            font-size: 13px;
            margin: 12px 0;
        }
        
        .timeline-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
            padding: 8px;
            border-radius: 6px;
            background: #f7fafc;
        }
        .timeline-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 12px;
            flex-shrink: 0;
        }
        .icon-success { background: #38a169; }
        .icon-pending { background: #d69e2e; }
        .icon-failed { background: #e53e3e; }
    </style>
</head>
<body>
    <div class="environment-badge" id="envBadge">üîç Detecting...</div>
    
    <div class="card">
        <h1 style="margin: 0; font-size: 2.5rem; color: #2d3748; display: flex; align-items: center; gap: 12px;">
            üö® Production Payment System Diagnostic
        </h1>
        <p style="color: #718096; margin: 8px 0 0 0; font-size: 1.1rem;">
            Comprehensive analysis to ensure all successful orders have payment transaction records and RPC functions execute properly
        </p>
    </div>

    <div class="card">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2>üîß Diagnostic Controls</h2>
            <div>
                <button class="btn-primary" onclick="runQuickDiagnostic()" id="quickBtn">
                    üìä Quick Scan (24h)
                </button>
                <button class="btn-secondary" onclick="runExtendedDiagnostic()" id="extendedBtn">
                    üìà Extended Scan (72h)
                </button>
                <button class="btn-danger" onclick="runRepairProcess()" id="repairBtn" style="display: none;">
                    üîß Auto-Repair Issues
                </button>
            </div>
        </div>
        
        <div id="summary-stats" style="display: none;"></div>
    </div>

    <div id="results"></div>

    <script>
        const SUPABASE_URL = 'https://oknnklksdiqaifhxaccs.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9rbm5rbGtzZGlxYWlmaHhhY2NzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMxOTA5MTQsImV4cCI6MjA2ODc2NjkxNH0.3X0OFCvuaEnf5BUxaCyYDSf1xE1uDBV4P0XBWjfy0IA';
        
        let currentDiagnosticReport = null;

        // Detect environment
        const environment = window.location.hostname.includes('localhost') ? 'development' : 'production';
        document.getElementById('envBadge').className = `environment-badge env-${environment}`;
        document.getElementById('envBadge').textContent = environment === 'production' ? 'üö® PRODUCTION' : 'üß™ Development';

        function addResult(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `diagnostic-result ${type}`;
            div.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            document.getElementById('results').appendChild(div);
            console.log(`[${type.toUpperCase()}] ${message}`);
            div.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }

        function setLoading(buttonId, isLoading) {
            const btn = document.getElementById(buttonId);
            if (isLoading) {
                btn.disabled = true;
                btn.innerHTML = '<span class="loading"></span> Processing...';
            } else {
                btn.disabled = false;
                btn.innerHTML = btn.id === 'quickBtn' ? 'üìä Quick Scan (24h)' : 'üìà Extended Scan (72h)';
            }
        }

        async function scanOrders(hoursBack) {
            const cutoffTime = new Date(Date.now() - hoursBack * 60 * 60 * 1000).toISOString();
            
            addResult(`üîç Scanning orders from last ${hoursBack} hours...`, 'info');
            
            const response = await fetch(`${SUPABASE_URL}/rest/v1/orders?created_at=gte.${cutoffTime}&select=*&order=created_at.desc`, {
                headers: {
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'apikey': SUPABASE_ANON_KEY
                }
            });

            if (!response.ok) {
                throw new Error(`Failed to fetch orders: ${response.status}`);
            }

            const orders = await response.json();
            addResult(`üìä Found ${orders.length} orders in the last ${hoursBack} hours`, 'success');
            return orders;
        }

        async function getPaymentTransactions(orderIds, paymentReferences) {
            const transactions = [];
            
            // Get transactions by order ID
            if (orderIds.length > 0) {
                const response1 = await fetch(`${SUPABASE_URL}/rest/v1/payment_transactions?order_id=in.(${orderIds.join(',')})&select=*`, {
                    headers: {
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'apikey': SUPABASE_ANON_KEY
                    }
                });
                if (response1.ok) {
                    const txns1 = await response1.json();
                    transactions.push(...txns1);
                }
            }

            // Get transactions by reference
            if (paymentReferences.length > 0) {
                const response2 = await fetch(`${SUPABASE_URL}/rest/v1/payment_transactions?reference=in.(${paymentReferences.map(r => `"${r}"`).join(',')})&select=*`, {
                    headers: {
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'apikey': SUPABASE_ANON_KEY
                    }
                });
                if (response2.ok) {
                    const txns2 = await response2.json();
                    transactions.push(...txns2);
                }
            }

            // Deduplicate
            const uniqueTransactions = transactions.filter((txn, index, self) => 
                index === self.findIndex(t => t.id === txn.id)
            );

            return uniqueTransactions;
        }

        async function testRPCFunction() {
            addResult('üîß Testing RPC function availability...', 'info');
            
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/verify_and_update_payment_status`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'apikey': SUPABASE_ANON_KEY
                    },
                    body: JSON.stringify({
                        payment_ref: `diagnostic_test_${Date.now()}`,
                        new_status: 'confirmed',
                        payment_amount: 100
                    })
                });

                const data = await response.json();
                
                if (response.status === 404 && data.message && data.message.includes('not found')) {
                    return {
                        available: true,
                        status: 'functional',
                        message: 'RPC function exists and responds correctly'
                    };
                } else if (response.status === 404 && data.message && data.message.includes('function')) {
                    return {
                        available: false,
                        status: 'missing',
                        message: 'RPC function does not exist in database',
                        error: data.message
                    };
                } else if (response.ok && data.length > 0) {
                    return {
                        available: true,
                        status: 'functional',
                        message: 'RPC function responded successfully'
                    };
                } else {
                    return {
                        available: false,
                        status: 'error',
                        message: 'RPC function exists but has errors',
                        error: data.message || 'Unknown error'
                    };
                }
            } catch (error) {
                return {
                    available: false,
                    status: 'error',
                    message: 'Failed to test RPC function',
                    error: error.message
                };
            }
        }

        function identifyPaymentGaps(orders, transactions) {
            const gaps = [];
            
            // Create lookup maps
            const transactionsByOrderId = new Map();
            const transactionsByReference = new Map();
            
            transactions.forEach(txn => {
                if (txn.order_id) transactionsByOrderId.set(txn.order_id, txn);
                if (txn.reference) transactionsByReference.set(txn.reference, txn);
            });

            orders.forEach(order => {
                const hasTransactionByOrderId = transactionsByOrderId.has(order.id);
                const hasTransactionByReference = order.payment_reference ? 
                    transactionsByReference.has(order.payment_reference) : false;
                
                const hasAnyTransaction = hasTransactionByOrderId || hasTransactionByReference;
                
                // Identify gap scenarios
                const isPaidButNoRecord = order.payment_status === 'paid' && !hasAnyTransaction;
                const isConfirmedButNoRecord = order.status === 'confirmed' && !hasAnyTransaction;
                const hasPaymentRefButNoRecord = order.payment_reference && !hasAnyTransaction;
                
                if (isPaidButNoRecord || isConfirmedButNoRecord || hasPaymentRefButNoRecord) {
                    gaps.push({
                        order_id: order.id,
                        order_number: order.order_number || 'Unknown',
                        payment_reference: order.payment_reference || 'None',
                        order_status: order.status,
                        payment_status: order.payment_status,
                        total_amount: order.total_amount || 0,
                        created_at: order.created_at,
                        missing_transaction_record: !hasAnyTransaction,
                        payment_verified_but_no_record: isPaidButNoRecord
                    });
                }
            });

            return gaps;
        }

        function generateReport(orders, transactions, rpcResults, gaps) {
            const successfulOrders = orders.filter(o => 
                o.status === 'confirmed' && o.payment_status === 'paid'
            ).length;
            
            const ordersWithPaymentRecords = orders.filter(order => {
                return transactions.some(txn => 
                    txn.order_id === order.id || txn.reference === order.payment_reference
                );
            }).length;

            const summary = {
                total_orders_scanned: orders.length,
                successful_orders: successfulOrders,
                orders_with_payment_records: ordersWithPaymentRecords,
                orders_missing_payment_records: orders.length - ordersWithPaymentRecords,
                orders_with_incomplete_status: orders.filter(o => 
                    (o.payment_reference && o.payment_status !== 'paid') ||
                    (o.payment_status === 'paid' && o.status !== 'confirmed')
                ).length,
                rpc_function_available: rpcResults.available,
                critical_issues_count: 0
            };

            const criticalIssues = [];
            const recommendations = [];

            // Analyze issues
            if (!rpcResults.available) {
                criticalIssues.push('‚ùå RPC function verify_and_update_payment_status is not available');
                recommendations.push('üîß Deploy the missing RPC function migration immediately');
                summary.critical_issues_count++;
            }

            if (gaps.length > 0) {
                criticalIssues.push(`‚ùå ${gaps.length} orders found with missing payment transaction records`);
                recommendations.push('üí≥ Backfill missing payment transaction records for successful orders');
                summary.critical_issues_count++;
            }

            if (gaps.filter(g => g.payment_status === 'paid').length > 0) {
                criticalIssues.push(`üö® ${gaps.filter(g => g.payment_status === 'paid').length} PAID orders have no payment transaction records`);
                recommendations.push('üî• URGENT: Create payment transaction records for paid orders');
                summary.critical_issues_count++;
            }

            if (summary.critical_issues_count === 0) {
                recommendations.push('‚úÖ Payment system is functioning correctly');
            }

            return {
                scan_timestamp: new Date().toISOString(),
                environment,
                summary,
                gaps_found: gaps,
                rpc_test_results: rpcResults,
                critical_issues: criticalIssues,
                recommendations
            };
        }

        function displayReport(report) {
            currentDiagnosticReport = report;
            
            // Summary stats
            const healthStatus = report.critical_issues.length > 0 ? 'critical' : 
                               report.gaps_found.length > 0 ? 'warning' : 'success';
            
            const statsHtml = `
                <div class="grid grid-4">
                    <div class="stat-card" style="background: ${healthStatus === 'critical' ? 'linear-gradient(135deg, #e53e3e, #c53030)' : 
                                                               healthStatus === 'warning' ? 'linear-gradient(135deg, #d69e2e, #b7791f)' : 
                                                               'linear-gradient(135deg, #38a169, #2f855a)'};">
                        <div class="stat-label">System Health</div>
                        <div class="stat-number">${healthStatus === 'critical' ? 'üö®' : healthStatus === 'warning' ? '‚ö†Ô∏è' : '‚úÖ'}</div>
                        <div class="stat-label">${healthStatus.toUpperCase()}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Orders Scanned</div>
                        <div class="stat-number">${report.summary.total_orders_scanned}</div>
                        <div class="stat-label">Last ${report.environment === 'production' ? '24' : '24'} Hours</div>
                    </div>
                    <div class="stat-card" style="background: ${report.summary.orders_missing_payment_records > 0 ? 
                        'linear-gradient(135deg, #e53e3e, #c53030)' : 'linear-gradient(135deg, #38a169, #2f855a)'};">
                        <div class="stat-label">Missing Records</div>
                        <div class="stat-number">${report.summary.orders_missing_payment_records}</div>
                        <div class="stat-label">Payment Transactions</div>
                    </div>
                    <div class="stat-card" style="background: ${report.critical_issues.length > 0 ? 
                        'linear-gradient(135deg, #e53e3e, #c53030)' : 'linear-gradient(135deg, #38a169, #2f855a)'};">
                        <div class="stat-label">Critical Issues</div>
                        <div class="stat-number">${report.critical_issues.length}</div>
                        <div class="stat-label">Require Attention</div>
                    </div>
                </div>
            `;
            
            document.getElementById('summary-stats').innerHTML = statsHtml;
            document.getElementById('summary-stats').style.display = 'block';

            // Show repair button if there are gaps
            if (report.gaps_found.length > 0) {
                document.getElementById('repairBtn').style.display = 'inline-block';
            }

            // Critical issues
            if (report.critical_issues.length > 0) {
                let issuesHtml = `<div class="card">
                    <h2 style="color: #e53e3e;">üö® Critical Issues Detected</h2>
                    <ul style="margin: 12px 0; color: #742a2a;">`;
                
                report.critical_issues.forEach(issue => {
                    issuesHtml += `<li style="margin: 8px 0;">${issue}</li>`;
                });
                
                issuesHtml += `</ul></div>`;
                addResult(issuesHtml, 'critical');
            }

            // Payment coverage analysis
            const coveragePercent = (report.summary.orders_with_payment_records / report.summary.total_orders_scanned) * 100;
            const successPercent = (report.summary.successful_orders / report.summary.total_orders_scanned) * 100;
            
            const coverageHtml = `
                <div class="card">
                    <h2>üìä Payment Coverage Analysis</h2>
                    <div class="grid grid-2">
                        <div>
                            <h4>Orders with Payment Records</h4>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${coveragePercent}%"></div>
                            </div>
                            <p>${report.summary.orders_with_payment_records}/${report.summary.total_orders_scanned} (${coveragePercent.toFixed(1)}%)</p>
                        </div>
                        <div>
                            <h4>Successful Orders</h4>
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${successPercent}%"></div>
                            </div>
                            <p>${report.summary.successful_orders}/${report.summary.total_orders_scanned} (${successPercent.toFixed(1)}%)</p>
                        </div>
                    </div>
                </div>
            `;
            addResult(coverageHtml, 'info');

            // RPC Function Status
            const rpcStatusHtml = `
                <div class="card">
                    <h2>üîß RPC Function Status</h2>
                    <div style="display: flex; align-items: center; gap: 12px; margin: 12px 0;">
                        <span class="status-badge ${report.rpc_test_results.available ? 'badge-success' : 'badge-danger'}">
                            ${report.rpc_test_results.available ? '‚úÖ Available' : '‚ùå Missing'}
                        </span>
                        <span class="status-badge badge-${report.rpc_test_results.status === 'functional' ? 'success' : 'danger'}">
                            ${report.rpc_test_results.status}
                        </span>
                    </div>
                    <p><strong>Message:</strong> ${report.rpc_test_results.message}</p>
                    ${report.rpc_test_results.error ? `<p style="color: #e53e3e;"><strong>Error:</strong> ${report.rpc_test_results.error}</p>` : ''}
                </div>
            `;
            addResult(rpcStatusHtml, report.rpc_test_results.available ? 'success' : 'critical');

            // Payment gaps
            if (report.gaps_found.length > 0) {
                let gapsHtml = `
                    <div class="card">
                        <h2>‚ö†Ô∏è Orders Missing Payment Transaction Records (${report.gaps_found.length})</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Order</th>
                                    <th>Payment Reference</th>
                                    <th>Status</th>
                                    <th>Amount</th>
                                    <th>Created</th>
                                </tr>
                            </thead>
                            <tbody>`;
                
                report.gaps_found.forEach(gap => {
                    gapsHtml += `
                        <tr>
                            <td>
                                <strong>${gap.order_number}</strong><br>
                                <small style="color: #718096;">${gap.order_id}</small>
                            </td>
                            <td><code style="font-size: 11px;">${gap.payment_reference}</code></td>
                            <td>
                                <span class="status-badge ${gap.order_status === 'confirmed' ? 'badge-success' : 'badge-warning'}">${gap.order_status}</span><br>
                                <span class="status-badge ${gap.payment_status === 'paid' ? 'badge-success' : 'badge-warning'}">${gap.payment_status}</span>
                            </td>
                            <td>‚Ç¶${gap.total_amount.toLocaleString()}</td>
                            <td>${new Date(gap.created_at).toLocaleDateString()}</td>
                        </tr>`;
                });
                
                gapsHtml += `</tbody></table></div>`;
                addResult(gapsHtml, 'warning');
            } else {
                addResult(`
                    <div class="card">
                        <h2>‚úÖ No Payment Gaps Found</h2>
                        <p style="color: #38a169;">All orders have proper payment transaction records. The payment system is functioning correctly.</p>
                    </div>
                `, 'success');
            }

            // Recommendations
            let recHtml = `
                <div class="card">
                    <h2>üí° Recommendations</h2>
                    <ul style="margin: 12px 0;">`;
            
            report.recommendations.forEach(rec => {
                recHtml += `<li style="margin: 8px 0;">${rec}</li>`;
            });
            
            recHtml += `</ul></div>`;
            addResult(recHtml, 'info');
        }

        async function runDiagnostic(hoursBack, buttonId) {
            setLoading(buttonId, true);
            document.getElementById('results').innerHTML = '';
            
            try {
                addResult('üöÄ Starting Production Payment System Diagnostic...', 'info');
                
                // Step 1: Scan orders
                const orders = await scanOrders(hoursBack);
                
                // Step 2: Get payment transactions
                addResult('üí≥ Fetching payment transaction records...', 'info');
                const orderIds = orders.map(o => o.id);
                const paymentReferences = orders.filter(o => o.payment_reference).map(o => o.payment_reference);
                const transactions = await getPaymentTransactions(orderIds, paymentReferences);
                addResult(`üìä Found ${transactions.length} payment transaction records`, 'success');
                
                // Step 3: Test RPC function
                const rpcResults = await testRPCFunction();
                if (rpcResults.available) {
                    addResult('‚úÖ RPC function is available and functional', 'success');
                } else {
                    addResult(`‚ùå RPC function issue: ${rpcResults.message}`, 'critical');
                }
                
                // Step 4: Identify gaps
                addResult('üîç Analyzing payment record completeness...', 'info');
                const gaps = identifyPaymentGaps(orders, transactions);
                
                if (gaps.length === 0) {
                    addResult('‚úÖ No payment record gaps found', 'success');
                } else {
                    addResult(`‚ö†Ô∏è Found ${gaps.length} orders with missing payment transaction records`, 'warning');
                }
                
                // Step 5: Generate and display report
                const report = generateReport(orders, transactions, rpcResults, gaps);
                displayReport(report);
                
                addResult('üìä Production diagnostic completed successfully', 'success');
                
            } catch (error) {
                addResult(`‚ùå Diagnostic failed: ${error.message}`, 'critical');
                console.error('Diagnostic error:', error);
            } finally {
                setLoading(buttonId, false);
            }
        }

        async function runQuickDiagnostic() {
            await runDiagnostic(24, 'quickBtn');
        }

        async function runExtendedDiagnostic() {
            await runDiagnostic(72, 'extendedBtn');
        }

        async function runRepairProcess() {
            if (!currentDiagnosticReport || currentDiagnosticReport.gaps_found.length === 0) {
                addResult('‚ö†Ô∏è No gaps found to repair', 'warning');
                return;
            }

            const gaps = currentDiagnosticReport.gaps_found;
            addResult(`üîß Starting auto-repair process for ${gaps.length} payment record gaps...`, 'info');
            
            let repaired = 0;
            let failed = 0;
            const errors = [];

            for (const gap of gaps) {
                try {
                    addResult(`üîß Repairing order ${gap.order_number} (${gap.payment_reference})...`, 'info');
                    
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/verify_and_update_payment_status`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'apikey': SUPABASE_ANON_KEY
                        },
                        body: JSON.stringify({
                            payment_ref: gap.payment_reference,
                            new_status: 'confirmed',
                            payment_amount: gap.total_amount,
                            payment_gateway_response: {
                                repair: true,
                                original_order_id: gap.order_id,
                                repair_timestamp: new Date().toISOString(),
                                status: 'success'
                            }
                        })
                    });

                    const data = await response.json();
                    
                    if (response.ok && data.length > 0) {
                        repaired++;
                        addResult(`‚úÖ Successfully repaired order ${gap.order_number}`, 'success');
                    } else {
                        failed++;
                        const errorMsg = data.message || `HTTP ${response.status}`;
                        errors.push(`${gap.order_number}: ${errorMsg}`);
                        addResult(`‚ùå Failed to repair ${gap.order_number}: ${errorMsg}`, 'critical');
                    }
                } catch (error) {
                    failed++;
                    errors.push(`${gap.order_number}: ${error.message}`);
                    addResult(`‚ùå Exception repairing ${gap.order_number}: ${error.message}`, 'critical');
                }
            }

            // Display repair summary
            const summaryHtml = `
                <div class="card">
                    <h2>üîß Repair Process Complete</h2>
                    <div class="grid grid-4">
                        <div class="stat-card" style="background: linear-gradient(135deg, #38a169, #2f855a);">
                            <div class="stat-label">Successfully Repaired</div>
                            <div class="stat-number">${repaired}</div>
                        </div>
                        <div class="stat-card" style="background: linear-gradient(135deg, #e53e3e, #c53030);">
                            <div class="stat-label">Failed to Repair</div>
                            <div class="stat-number">${failed}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Total Processed</div>
                            <div class="stat-number">${repaired + failed}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Success Rate</div>
                            <div class="stat-number">${Math.round((repaired / (repaired + failed)) * 100)}%</div>
                        </div>
                    </div>
                    ${errors.length > 0 ? `
                        <h3>‚ùå Errors:</h3>
                        <ul style="color: #e53e3e;">
                            ${errors.map(err => `<li>${err}</li>`).join('')}
                        </ul>
                    ` : ''}
                </div>
            `;
            
            addResult(summaryHtml, repaired > 0 ? 'success' : 'critical');
            
            if (repaired > 0) {
                addResult('üîÑ Re-running diagnostic to verify repairs...', 'info');
                setTimeout(() => {
                    runQuickDiagnostic();
                }, 2000);
            }
        }

        // Auto-run diagnostic on page load for production
        document.addEventListener('DOMContentLoaded', () => {
            addResult('üöÄ Production Payment Diagnostic Tool Loaded', 'info');
            addResult(`üåç Environment detected: ${environment}`, 'info');
            
            if (environment === 'production') {
                addResult('üö® Running automatic diagnostic for production environment...', 'info');
                setTimeout(() => {
                    runQuickDiagnostic();
                }, 2000);
            } else {
                addResult('üß™ Development environment detected. Click a button to run diagnostic.', 'info');
            }
        });
    </script>
</body>
</html>
